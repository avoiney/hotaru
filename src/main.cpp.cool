#include <iostream>
#include <vector>
#include <cmath>
#include <SDL/SDL.h>
#include <ctime>

int cpt = 0;
const int itPerSec = 500;

static const size_t WINDOW_WIDTH = 512;
static const size_t WINDOW_HEIGHT = 512;
static const size_t BYTES_PER_PIXEL = 32;
static const char* WINDOW_TITLE = "Imac Particle System";
static int NB_PARTICLE = 8;
static int N_SEC = 15;

#include "api/wave.h"
#include "api/Particle.hpp"
#include "api/Spring.hpp"
#include "api/LeapfrogSolver.hpp"
#include "api/Polygon.hpp"
#include "api/PolygonSpring.hpp"
#include "api/ConstantSpring.hpp"
#include "api/HookSpring.hpp"
#include "api/FluidSpring.hpp"
#include "api/ViscuoseSpring.hpp"
#include "api/CineticBrake.hpp"
#include "api/AttractiveSpring.hpp"
#include "api/Box.hpp"
#include "api/Circle.hpp"
#include "renderer/GLRenderer.hpp"

#define DO      0.037275246167682
#define RE      0.041840030159809
#define MI      0.046963889416093
#define FA      0.049756558695141
#define SOL     0.055849823684532
#define LA      0.062689377214490
#define SI      0.070366403833691
#define DO_1    0.074550634811044
#define DTMAX   0.000001

using namespace std;


int main(int argc, char** argv) {
    char* name;
    if(argc > 1){
        if(argc > 2){
            if(argc > 3) {
                NB_PARTICLE = atoi(argv[3]);
            }
            N_SEC = atoi(argv[2]);
        }
        name = strcat(argv[1] ,".wav");
    }else{
        name = "test.wav";
    }

    struct wave wav = { 0 };
    FILE *fich = fopen(name, "wb+");
    
    if (fich == NULL)
        return EXIT_FAILURE;
    
    /* Seul les paramètres taille, subTaille2 et data ne sont pas initialisés */
    initWave(&wav);

    // Initialisation de la SDL
    SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO);
    SDL_SetVideoMode(WINDOW_WIDTH, WINDOW_HEIGHT, BYTES_PER_PIXEL, SDL_OPENGL);
    SDL_WM_SetCaption(WINDOW_TITLE, 0);
    static float dt = DTMAX; // Pas de simulation, choix arbitraire mais dois rester petit pour que le systeme n'explose pas;

    // Creation du renderer
    GLRenderer renderer;

    /** Placez votre code d'initialisation de la simulation ici **/
    ConstantSpring gravity(glm::vec2(0, -9.81)); // pointe vers le bas, 3 est un choix arbitraire
    ViscuoseSpring eau(1.002 * 10);
    FluidSpring fluidSpring(dt, 0.00000000000000000000001, 80000);
    AttractiveSpring gravitation(100, 1.2);
    LeapfrogSolver solver;

    std::vector<Polygon> obstacles;
    
    // Content Box
    obstacles.push_back(Polygon(Col3f(0, 0, 0), true)); // polygone interne
    Box::build(glm::vec2(-0.9, -0.9), 1.8, 1.8, obstacles.back());


    obstacles.push_back(Polygon(Col3f(1, 0, 0), false)); // polygone externe
    Circle c(glm::vec2(0.,-0.2), 0.2, 1000.);
    c.build(obstacles.back());

    obstacles.push_back(Polygon(Col3f(1, 1, 1), false)); // polygone externe
    Circle c2(glm::vec2(0.7,-0.7), 0., 0.);
    c2.build(obstacles.back());

    for(size_t i = 0; i < obstacles.size(); ++i) {
        renderer.addPolygon(&obstacles[i].getVertices()[0], obstacles[i].size(), obstacles[i].color);
    }



    // Code d'exemple pour le rendu: des particles placées en cercle
    std::vector<Particle> particles;

    float wallElasticity = 2.; // Les particules vont tomber après quelques rebonds
    // Creation des ressort de collision
    std::vector<PolygonSpring> polygonSprings;
    for(size_t i = 0; i < obstacles.size(); ++i) {
            polygonSprings.push_back(PolygonSpring(obstacles[i], wallElasticity, solver, dt));
    }

    float delta = 2 * 3.14 / NB_PARTICLE; // 2pi / nombre de particules
    double notes[13] = {DO, DO + DO/2, RE, RE + RE/2, MI, FA, FA + FA/2, SOL, SOL + SOL/2, LA, LA + LA/2, SI, DO_1};
    for(size_t i = 0, j = 0 ; i < NB_PARTICLE; ++i, ++j) {
        double note;
        if(j < 13) note = notes[j];
        else note = 0;
        float c = cos(i * delta), s = sin(i * delta);
        float r3 = -.7 + (float)rand()/((float)RAND_MAX/(1.4));
        float r4 = .3 + (float)rand()/((float)RAND_MAX/(.1));
        particles.push_back(Particle(glm::vec2(r3, r4), glm::vec2(0,0), glm::vec3(c, 1, 1), float(0.5), note));
    }


    
    double val = 0;
    bool done = false;
    
    while(!done) {
        static double current_time = 0;
        static double last_time = 0;
        static int n = 0;
        static int fps = n;

        n++;
        current_time = time(NULL);

        if ((current_time - last_time) >= 1.0)
        {
           // nombre de frames par seconde
           fps = n;
           n = 0;
           last_time = current_time;
        }
        std::cout << fps << std::endl;

        // Rendu
        renderer.render(&particles[0], particles.size());
        SDL_GL_SwapBuffers();

        /** Placez votre code de simulation ici */
        //Application de la gravité sur chaque particule:
        for(size_t i = 0; i < particles.size(); ++i) {
            gravity.generateForces(&particles[i], 0);
            gravitation.generateForces(&particles[i], &c);
            eau.generateForces(&particles[i], 0);
        }

        for(size_t i = 0 ; i < particles.size() ; ++i) {
            for(size_t j = i+1 ; j < particles.size() ; ++j) {
                fluidSpring.generateForces(&particles[i], &particles[j]);
                gravitation.generateForces(&particles[i], &particles[j]);
            }
        }

        for(size_t i = 0; i < particles.size() ; ++i) { // Pour chaque particule
            for(size_t j = 0; j < polygonSprings.size(); ++j) { // Pour chaque ressort de collision
                done |= polygonSprings[j].generateForces(&particles[i], 0, &wav); // Test de collision et génération des forces
            }
        }  


        for(size_t i = 0; i < particles.size() ; ++i) {
            solver.solve(dt, particles[i]);
        }

    

        /** Placez votre gestion des évenements ici */
        SDL_Event e;
        static float dt_tmp;
        while(SDL_PollEvent(&e)) {
            if(e.type == SDL_KEYDOWN) {
                SDLKey keyText = e.key.keysym.sym;
                // printf("The %s key was pressed!\n", SDL_GetKeyName(keyText));
                
                if(keyText == SDLK_ESCAPE)
                    done = true;

                if(keyText == SDLK_KP_PLUS){
                    if(dt < DTMAX)
                        dt += DTMAX/10;
                    printf("dt : %f\n", dt);
                }

                if(keyText == SDLK_KP_MINUS){
                    if(dt > .0)
                        dt -= DTMAX/10;
                    printf("dt : %f\n", dt);
                }
                    
                

                break;
            }
            if(e.type == SDL_MOUSEBUTTONDOWN) {
                if(e.button.button == SDL_BUTTON_LEFT && dt == 0)
                    dt = dt_tmp;
                else if(e.button.button == SDL_BUTTON_LEFT && dt != 0) {
                    dt_tmp = dt;
                    dt = 0;
                }
                break;
            }

            if(e.type == SDL_QUIT) {
                done = true;
                break;
            }

            
        }
        cpt++;
    }

    SDL_Quit();

    fwrite(&wav, T_ENTETE, 1, fich);
    /* On écris les data */
    fwrite(wav.data, wav.subTaille2, 1, fich);
    
    /* On libère notre mémoire, et on ferme le fichier */
    free(wav.data);
    fclose(fich);
    return 0;
}
