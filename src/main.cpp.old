#include <iostream>
#include <vector>
#include <cmath>
#include <SDL/SDL.h>
#include <ctime>


#include "api/Particle.hpp"
#include "api/Spring.hpp"
#include "api/LeapfrogSolver.hpp"
#include "api/Polygon.hpp"
#include "api/PolygonSpring.hpp"
#include "api/ConstantSpring.hpp"
#include "api/HookSpring.hpp"
#include "api/FluidSpring.hpp"
#include "api/ViscuoseSpring.hpp"
#include "api/CineticBrake.hpp"
#include "api/AttractiveSpring.hpp"
#include "api/Box.hpp"
#include "api/Circle.hpp"
#include "renderer/GLRenderer.hpp"


using namespace std;

static const size_t WINDOW_WIDTH = 512;
static const size_t WINDOW_HEIGHT = 512;
static const size_t BYTES_PER_PIXEL = 32;
static const char* WINDOW_TITLE = "Imac Particle System";
static const int NB_PARTICLE = 50;

int main(int argc, char** argv) {
    // Initialisation de la SDL
    SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO);
    SDL_SetVideoMode(WINDOW_WIDTH, WINDOW_HEIGHT, BYTES_PER_PIXEL, SDL_OPENGL);
    SDL_WM_SetCaption(WINDOW_TITLE, 0);
    static float dt = 0.000001; // Pas de simulation, choix arbitraire mais dois rester petit pour que le systeme n'explose pas;

    // Creation du renderer
    GLRenderer renderer;

    /** Placez votre code d'initialisation de la simulation ici **/
    ConstantSpring gravity(glm::vec2(0, -9.81)); // pointe vers le bas, 3 est un choix arbitraire
    /*
        // expansion + oscillation sur les bords

        ViscuoseSpring eau(1.002 * 1000);
        HookSpring hook(800,1.5);
        LeapfrogSolver solver;
        static float dt = 0.00005; // Pas de simulation, choix arbitraire mais dois rester petit pour que le systeme n'explose pas;
        CineticBrake fluidSpring(dt, 0.000000001);
    */
    ViscuoseSpring eau(1.002 * 10);
    FluidSpring fluidSpring(dt, 0.00000000000000000000001, 0.008);
    AttractiveSpring gravitation(100, 0.6);
    LeapfrogSolver solver;

    std::vector<Polygon> obstacles;
    
    // Content Box
    obstacles.push_back(Polygon(Col3f(0, 0, 0), true)); // polygone interne
    Box::build(glm::vec2(-0.9, -0.9), 1.8, 1.8, obstacles.back());

//    1rst Little Box
    //obstacles.push_back(Polygon(Col3f(1, 1, 0), true)); // polygone externe
    //Box::build(glm::vec2(0.2, 0.2), .5, -.2, obstacles.back());

  //  2nd Little Box
    //obstacles.push_back(Polygon(Col3f(1, 0, 0), true)); // polygone externe
    //Box::build(glm::vec2(-0.2, -0.2), .5, -.2, obstacles.back());

     // obstacles.push_back(Polygon(Col3f(1, 1, 1), true)); // polygone externe
     // Circle::build(glm::vec2(0,0), 0.6, obstacles.back());

    obstacles.push_back(Polygon(Col3f(0, 0, 0), false)); // polygone externe
    Circle c(glm::vec2(0.,0), 0.1, 500.);
    c.build(obstacles.back());

    obstacles.push_back(Polygon(Col3f(1, 1, 1), false)); // polygone externe
    Circle c2(glm::vec2(0.7,-0.7), 0., 500.);
    c2.build(obstacles.back());
     // obstacles.push_back(Polygon(Col3f(1, 1, 1), false)); // polygone externe
     // Circle::build(glm::vec2(0.,0), 0.3, obstacles.back());

    for(size_t i = 0; i < obstacles.size(); ++i) {
        renderer.addPolygon(&obstacles[i].getVertices()[0], obstacles[i].size(), obstacles[i].color);
    }



    // Code d'exemple pour le rendu: des particles placées en cercle
    std::vector<Particle> particles;

    float wallElasticity = 2.; // Les particules vont tomber après quelques rebonds
    // Creation des ressort de collision
    std::vector<PolygonSpring> polygonSprings;
    for(size_t i = 0; i < obstacles.size(); ++i) {
            polygonSprings.push_back(PolygonSpring(obstacles[i], wallElasticity, solver, dt));
    }

    float delta = 2 * 3.14 / NB_PARTICLE; // 2pi / nombre de particules
    for(size_t i = 0; i < NB_PARTICLE; ++i) {
        float c = cos(i * delta), s = sin(i * delta);
        particles.push_back(Particle(glm::vec2(0.5f * c, 0.5f * s), glm::vec2(0,0), glm::vec3(c, 1, 1), float(0.5)));
    }


    int cpt = 0;
    bool done = false;
    while(!done) {
        static double current_time = 0;
        static double last_time = 0;
        static int n = 0;
        static int fps = n;

        n++;
        current_time = time(NULL);

        if ((current_time - last_time) >= 1.0)
        {
           // nombre de frames par seconde
           fps = n;
           n = 0;
           last_time = current_time;
        }
        std::cout << fps << std::endl;

        // Rendu
        renderer.render(&particles[0], particles.size());
        SDL_GL_SwapBuffers();

        /** Placez votre code de simulation ici */
        //Application de la gravité sur chaque particule:
        for(size_t i = 0; i < particles.size(); ++i) {
            gravity.generateForces(&particles[i], 0);
            //gravitation.generateForces(&particles[particles.size()-1], &particles[i]);
            gravitation.generateForces(&particles[i], &c);
            //gravitation.generateForces(&particles[i], &c2);
            eau.generateForces(&particles[i], 0);
        }

        for(size_t i = 0 ; i < particles.size() ; ++i) {
            for(size_t j = i+1 ; j < particles.size() ; ++j) {
                //hook.generateForces(&particles[i], &particles[j]);
                fluidSpring.generateForces(&particles[i], &particles[j]);
                //gravitation.generateForces(&particles[i], &particles[j]);
            }
        }

        for(size_t i = 0; i < particles.size() ; ++i) { // Pour chaque particule
            for(size_t j = 0; j < polygonSprings.size(); ++j) { // Pour chaque ressort de collision
                polygonSprings[j].generateForces(&particles[i], 0); // Test de collision et génération des forces
            }
        }  


        for(size_t i = 0; i < particles.size() ; ++i) {
            solver.solve(dt, particles[i]);
        }

        // for(size_t i = 0; i < particles.size() ; ++i) {
        //     if(particles[i].position.y > 0 && particles[i].mass < 1.)
        //         particles[i].mass += 0.001*particles[i].position.y;
        //     if(particles[i].position.y < 0 && particles[i].mass > 0.5)
        //         particles[i].mass += 0.0001*particles[i].position.y;
        // }

        /** Placez votre gestion des évenements ici */
        SDL_Event e;
        static float dt_tmp;
        while(SDL_PollEvent(&e)) {
            if(e.type == SDL_KEYDOWN) {
                SDLKey keyText = e.key.keysym.sym;
                // printf("The %s key was pressed!\n", SDL_GetKeyName(keyText));
                
                if(keyText == SDLK_ESCAPE)
                    done = true;

                if(keyText == SDLK_KP_PLUS){
                    if(dt < .000051)
                        dt += .000001;
                    printf("dt : %f\n", dt);
                }

                if(keyText == SDLK_KP_MINUS){
                    if(dt > .0)
                        dt -= .000001;
                    printf("dt : %f\n", dt);
                }
                    
                

                break;
            }
            if(e.type == SDL_MOUSEBUTTONDOWN) {
                if(e.button.button == SDL_BUTTON_LEFT && dt == 0)
                    dt = dt_tmp;
                else if(e.button.button == SDL_BUTTON_LEFT && dt != 0) {
                    dt_tmp = dt;
                    dt = 0;
                }
                break;
            }

            if(e.type == SDL_QUIT) {
                done = true;
                break;
            }

            
        }
    }

    SDL_Quit();

    return 0;
}
